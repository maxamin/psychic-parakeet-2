/**************************************************************************
This firmware displays a DVID logo in a slick animation.
 **************************************************************************/

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define DVID_circuit_width 51
#define DVID_circuit_height 55
static const uint8_t PROGMEM DVID_circuit_bits[] = {
   0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe2, 0x08, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x05, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x07, 0x01, 0x00, 0x00, 0x00,
   0x80, 0xc0, 0x00, 0x01, 0x00, 0x00, 0x33, 0xb3, 0x60, 0x00, 0x01, 0x00,
   0x00, 0x33, 0xb3, 0x31, 0x00, 0x01, 0x00, 0x00, 0x00, 0x80, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x31, 0x07, 0x42,
   0x00, 0x00, 0x00, 0x80, 0xff, 0x05, 0x42, 0x00, 0x00, 0x00, 0x80, 0x31,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x80, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x30, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80, 0x30, 0x00, 0x42, 0x00,
   0x00, 0x00, 0x80, 0x31, 0x07, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x05,
   0x00, 0x00, 0x00, 0x00, 0x80, 0x31, 0x07, 0x42, 0x00, 0x00, 0x00, 0x80,
   0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x42,
   0x00, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80, 0x11,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x10, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x42, 0x00,
   0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80,
   0x10, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80, 0x38, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x38, 0x00, 0x42,
   0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x80, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
   0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xb8, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x18, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x86, 0x00, 0x00,
   0x01, 0x00, 0x00, 0x06, 0x83, 0x00, 0x00, 0x01, 0x00, 0x00, 0x83, 0x81,
   0x00, 0x00, 0x01, 0x00, 0x80, 0xc1, 0x80, 0x00, 0x00, 0x01, 0x00, 0xc0,
   0x60, 0x80, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x30,
   0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x30, 0x33, 0x03, 0x00, 0x00, 0x00,
   0x00 };
   
void setup() {
  Serial.begin(9600);

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

  // Show initial display buffer contents on the screen --
  // the library initializes this with an Adafruit splash screen.
  display.display();
  delay(2000); // Pause for 2 seconds

  // Clear the buffer
  display.clearDisplay();
  
}

void loop() {
   // Clear the buffer
  display.clearDisplay();

  drawDvid();
  delay(500);
  blinkCircuit();
  delay(2500);
}


void drawDvid() {
  // Bar width
  int16_t w = 4;
  // Starting point to draw the first D
  int16_t d1_x_pos = 7;
  int16_t d1_y_pos = 17;

  // Starting point to draw the second D
  int16_t d2_x_pos = 78;
  int16_t d2_y_pos = d1_y_pos;

  // Starting point to draw the V
  int16_t v_x_pos = 35;
  int16_t v_y_pos = d1_y_pos;
  int16_t v_slide = 0;
  // Array indicating how frequently to slide V
  int v_blocs_count = 12;
  int v_blocs[v_blocs_count] = {3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2};
  // y position end
  int16_t text_height = 32;
  int16_t text_y_end = d1_y_pos + text_height;
  
  // Animate the first parts of the D and V
  int16_t i;
  int16_t y;
  int16_t v_cursor = 0;
  int16_t v_count = v_blocs[v_cursor];
  for (i=0; i<text_height+1; i++) {
    y = d1_y_pos + i;
    // Draw first D
    display.drawLine(d1_x_pos, y, d1_x_pos+w, y, WHITE);
    // Draw second D in reverse
    display.drawLine(d2_x_pos, text_y_end-i, d2_x_pos+w, text_y_end-i, WHITE);
    // Draw V
    display.drawLine(v_x_pos+v_slide, y, v_x_pos+v_slide+w, y, WHITE);
    display.display();
    delay(1);

    // Slide V
    v_count--;
    if (v_count == 0) {
      v_slide++;
      v_cursor++;
      v_count = v_blocs[v_cursor];
    }
  }

  // Now draw the horizontal bar of the D
  int16_t d_bar_width = 10;
  
  for (i=0; i<d_bar_width+1; i++) {
    display.drawLine(d1_x_pos+w+1+i, d1_y_pos, d1_x_pos+w+1+i, d1_y_pos+w, WHITE);
    display.drawLine(d2_x_pos+w+1+i, d1_y_pos+text_height-w, d2_x_pos+w+1+i, d1_y_pos+text_height, WHITE);
    display.display();
    delay(2);
  }

  // Draw the vertical bars of the D, the V and the I
  int16_t i_x_pos = 67;
  int16_t d_blocs[] = {1,1,1,1,1,1,1,19,1,1,1,1,1,1,1};
  int16_t d_increment = 1;
  int16_t d_cursor = 0;
  int16_t d_count = d_blocs[d_cursor];
  int16_t d_slide = 0;
  
  d2_x_pos = 90;
  d1_x_pos = 19;
  v_x_pos = 47;
  v_slide = 0;
  v_cursor = v_blocs_count-1;
  v_count = v_blocs[v_cursor];
  for (i=0; i<text_height+1; i++) {
    y =  d1_y_pos + i;
    // draw the V
    display.drawLine(v_x_pos+v_slide, text_y_end-i, v_x_pos+v_slide+w, text_y_end-i, WHITE);
    // draw the I
    display.drawLine(i_x_pos, y, i_x_pos+w, y, WHITE);
    // draw D
    display.drawLine(d2_x_pos+d_slide, text_y_end-i, d2_x_pos+w+d_slide, text_y_end-i, WHITE);
    display.drawLine(d1_x_pos+d_slide, y, d1_x_pos+w+d_slide, y, WHITE);
    display.display();
    delay(1);

    // Slide V
    v_count--;
    if (v_count == 0) {
      v_slide++;
      v_cursor--;
      v_count = v_blocs[v_cursor];
    }

    // Slide D2
    d_count--;
    if (d_count == 0) {
      d_slide = d_slide+d_increment;
      d_cursor++;
      d_count = d_blocs[d_cursor];
      if (d_slide == 7) {
        d_increment = -1;
      }
    }
  }
  
  // Now draw the horizontal bar of the D
  d1_x_pos = d1_x_pos + d_slide -1;
  d2_x_pos = d2_x_pos + d_slide -1;
  for (i=0; i<d_bar_width+1; i++) {
    display.drawLine(d2_x_pos+w+1-i, d1_y_pos, d2_x_pos+w+1-i, d1_y_pos+w, WHITE);
    display.drawLine(d1_x_pos+w+1-i, d1_y_pos+text_height-w, d1_x_pos+w+1-i, d1_y_pos+text_height, WHITE);
    display.display();
    delay(2);
  }
}


void drawCircuit(int16_t color) {
  display.drawXBitmap(71,3,DVID_circuit_bits,DVID_circuit_width,DVID_circuit_height,color);
  display.display();
}

void blinkCircuit() {
  drawCircuit(WHITE);
  delay(35);
  drawCircuit(BLACK);
  delay(100);
  drawCircuit(WHITE);
  delay(400);
  drawCircuit(BLACK);
  delay(150);
  drawCircuit(WHITE);
  delay(5);
  drawCircuit(BLACK);
  delay(5);
  drawCircuit(WHITE);
}
