# Copyright 2022 Dynatrace LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Portions of this code, as identified in remarks, are provided under the
# Creative Commons BY-SA 4.0 or the MIT license, and are provided without
# any warranty. In each of the remarks, we have provided attribution to the
# original creators and other attribution parties, along with the title of
# the code (if known) a copyright notice and a link to the license, and a
# statement indicating whether or not we have modified the code.

import asyncio
from json import JSONDecodeError

import docker.errors
import pydantic.error_wrappers
from app.core.config import settings
from app.logic.exploit_manager import ExploitManager
from app.logic.util import convert_error_to_str
from app.models.exploit import Exploit, ExploitInfo
from app.models.step import Step
from app.models.websocket_input import WebsocketInput
from fastapi import APIRouter, HTTPException, WebSocket
from fastapi_utils.tasks import repeat_every

router = APIRouter()

exploit_manager = ExploitManager(
    exploit_folder=settings.INVADIUM_CONFIG_PATH,
    max_idle_time=settings.INVADIUM_EXPLOIT_TIMEOUT,
)


@router.post("/start", response_model=str)
async def start_exploit(exploit_id: str) -> str:
    """
    Start the container for the exploit
    """
    try:
        return exploit_manager.start_exploit_container(exploit_id)
    except KeyError:
        raise HTTPException(status_code=404, detail="Exploit not found")


@router.get("", response_model=list[ExploitInfo])
async def get_all_exploits() -> list[ExploitInfo]:
    return exploit_manager.get_all_exploits()


@router.get("/{exploit_id}/info", response_model=Exploit)
async def get_info_for_exploit(exploit_id: str) -> Exploit:
    try:
        return exploit_manager.get_exploit_info(exploit_id)
    except KeyError:
        raise HTTPException(status_code=404, detail="Exploit not found")


@router.get("/{exploit_id}/steps", response_model=list[Step])
async def get_all_steps_for_exploit(exploit_id: str) -> list[Step]:
    try:
        return exploit_manager.get_all_steps_for_exploit(exploit_id)
    except KeyError:
        raise HTTPException(status_code=404, detail="Exploit not found")


@router.get("/running/{container_id}/info")
async def get_running_exploit_info(container_id: str) -> Exploit:
    try:
        return exploit_manager.get_running_exploit_info(container_id)
    except KeyError:
        raise HTTPException(status_code=404, detail="Container not found")


@router.delete("/stop", response_model=str)
async def stop_container(container_id: str) -> str:
    """
    Stops the specified container

    :param container_id: The container id
    :return: Returns done when the container is successfully stopped
    """
    try:
        exploit_manager.stop_exploit_container(container_id)
        return "done"
    except KeyError as e:
        raise HTTPException(status_code=404, detail=convert_error_to_str(e))


@router.websocket("/ws-logs")
async def execute_and_stream_logs_from_websocket(websocket: WebSocket) -> None:
    """
    Sends a command to the specified container and
    returns the logs until the command is finished executing
    """
    await websocket.accept()

    try:
        json_response = await websocket.receive_json()

        ws_input = WebsocketInput.parse_obj(json_response)

        logs = exploit_manager.exec_step_and_stream_logs(
            ws_input.container_id, ws_input.step_id
        )
        if settings.INVADIUM_EXPLOIT_RUNTIME == "docker":
            for log in logs.output:
                await websocket.send_text(log.decode())
                # This is needed because websocket.send_text() doesn't work without it for some reason
                await asyncio.sleep(0.000000001)
        elif settings.INVADIUM_EXPLOIT_RUNTIME == "kubernetes":
            while logs.is_open():
                logs.update(timeout=1)
                if logs.peek_stdout():
                    await websocket.send_text(logs.read_stdout())
                if logs.peek_stderr():
                    await websocket.send_text(logs.read_stderr())
                await asyncio.sleep(0.000000001)
    except JSONDecodeError:
        await websocket.send_text("No valid JSON was provided")
    except docker.errors.NotFound:
        await websocket.send_text("Container Not Found")
    except pydantic.error_wrappers.ValidationError as e:
        await websocket.send_text(str(e))
    await websocket.close()


@router.on_event("startup")
@repeat_every(seconds=60)
def start_container_cleaning() -> None:
    exploit_manager.kill_idle_exploit_containers()
