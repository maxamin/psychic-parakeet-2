# Copyright 2022 Dynatrace LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Portions of this code, as identified in remarks, are provided under the
# Creative Commons BY-SA 4.0 or the MIT license, and are provided without
# any warranty. In each of the remarks, we have provided attribution to the
# original creators and other attribution parties, along with the title of
# the code (if known) a copyright notice and a link to the license, and a
# statement indicating whether or not we have modified the code.

import logging
import os
from datetime import datetime
from pathlib import Path

import yaml
from app.core.config import settings
from app.logic.docker_container_manager import DockerContainerManager
from app.logic.k8s_container_manager import K8sContainerManager
from app.models.environment_var import EnvironmentVar
from app.models.exploit import Exploit, ExploitInfo
from app.models.running_exploit import RunningExploit
from app.models.step import Step


class ExploitManager:
    def __init__(self, exploit_folder: str, max_idle_time: int):
        """
        :param exploit_folder: The folder path where the exploit config yaml files are
        :param max_idle_time: The idle time after a container will be stopped in seconds
        """
        self.exploits = None
        self.max_idle_time = max_idle_time
        self.exploit_folder = exploit_folder
        self.refresh_config()
        if settings.INVADIUM_EXPLOIT_RUNTIME == "docker":
            self.container_manager = DockerContainerManager()
        elif settings.INVADIUM_EXPLOIT_RUNTIME == "kubernetes":
            self.container_manager = K8sContainerManager()
        self.running_exploits = {}

    def refresh_config(self):
        self.exploits = self.read_all_exploit_files()

    def start_exploit_container(self, exploit_id):
        container_id = self.container_manager.start_container(
            self.exploits[exploit_id].image
        )
        self.running_exploits[container_id] = RunningExploit(
            container_id=container_id,
            exploit=self.exploits[exploit_id],
            last_step_execution=datetime.now(),
        )
        return container_id

    @staticmethod
    def add_to_env(name: str, value: str, env: dict[str, str]):
        if value is not None:
            env[name] = value

    def get_all_exploits(self) -> list[ExploitInfo]:
        return list(self.exploits.values())

    def get_all_steps_for_exploit(self, exploit_id: str) -> list[Step]:
        return list(self.exploits[exploit_id].steps.values())

    def exec_step_and_stream_logs(self, container_id, step_id: str):
        self.running_exploits[container_id].last_step_execution = datetime.now()
        return self.container_manager.exec_and_stream_logs(
            container_id,
            " && ".join(
                self.exploits[self.running_exploits[container_id].exploit.id]
                .steps[step_id]
                .commands
            ),
            self.convert_env_dict(self.running_exploits[container_id].exploit.env)
            | self.convert_env_dict(
                self.running_exploits[container_id].exploit.steps[step_id].env
            ),
        )

    def get_exploit_info(self, exploit_id: str) -> Exploit:
        return self.exploits[exploit_id]

    def stop_exploit_container(self, container_id: str):
        if container_id not in self.running_exploits:
            raise KeyError("Container not found")
        self.container_manager.stop_container(container_id)
        self.running_exploits.pop(container_id)

    def read_exploit_file(self, exploit_id: str) -> Exploit:
        with open(
            os.path.join(self.exploit_folder, f"{exploit_id}.yaml"), encoding="utf-8"
        ) as f:
            yaml_data = yaml.safe_load(f)

        exploit = Exploit(**yaml_data)

        return exploit

    def read_all_exploit_files(self) -> dict[str, Exploit]:
        exploits = {}
        if not os.path.exists(self.exploit_folder):
            logging.warning("Exploit config folder not found!")
            return exploits
        for file in os.listdir(os.path.join(self.exploit_folder)):
            if file.endswith(".yaml"):
                file_name = Path(file).resolve().stem
                exp = self.read_exploit_file(file_name)
                if exp.id in exploits:
                    raise ValueError(
                        f"Two or more files have the same exploit_id: {exp.id}"
                    )
                exploits[exp.id] = exp
        return exploits

    def kill_idle_exploit_containers(self) -> None:
        logging.info("starting container cleaning...")
        for exploits in self.running_exploits.values():
            time_since_last_step = datetime.now() - exploits.last_step_execution
            seconds = time_since_last_step.total_seconds()
            if seconds > self.max_idle_time:
                logging.info(
                    f"stopping container: {exploits.container_id} "
                    f"with exploit: {exploits.exploit.id} for idling too long..."
                )
                self.stop_exploit_container(exploits.container_id)
                logging.info(
                    f"stopped container: {exploits.container_id} "
                    f"with exploit: {exploits.exploit.id} for idling too long"
                )
        logging.info("finished container cleaning")

    def get_exploit_env(self, container_id: str) -> dict[str, EnvironmentVar]:
        if container_id not in self.running_exploits:
            raise KeyError("Container not found")
        return self.running_exploits[container_id].exploit.env

    def get_step_env(self, container_id, step_id) -> dict[str, EnvironmentVar]:
        if container_id not in self.running_exploits:
            raise KeyError("Container not found")
        if step_id not in self.running_exploits[container_id].exploit.steps:
            raise KeyError("Step not found")
        return self.running_exploits[container_id].exploit.steps[step_id].env

    def set_exploit_env(
        self, container_id: str, env_name: str, new_value: str
    ) -> EnvironmentVar:
        if container_id not in self.running_exploits:
            raise KeyError("Container not found")
        if env_name not in self.running_exploits[container_id].exploit.env:
            raise KeyError("Env not found")
        self.running_exploits[container_id].exploit.env[env_name].value = new_value
        return self.running_exploits[container_id].exploit.env[env_name]

    def set_step_env(
        self, container_id: str, step_id: str, env_name: str, new_value: str
    ) -> EnvironmentVar:
        if container_id not in self.running_exploits:
            raise KeyError("Container not found")
        if step_id not in self.running_exploits[container_id].exploit.steps:
            raise KeyError("Step not found")
        if (
            env_name
            not in self.running_exploits[container_id].exploit.steps[step_id].env
        ):
            raise KeyError("Env not found")
        self.running_exploits[container_id].exploit.steps[step_id].env[
            env_name
        ].value = new_value
        return self.running_exploits[container_id].exploit.steps[step_id].env[env_name]

    @staticmethod
    def convert_env_dict(env: dict[str, EnvironmentVar]) -> dict[str, str]:
        out_dict = {}
        for key, value in env.items():
            out_dict[value.name] = value.value
        return out_dict

    def get_running_exploit_info(self, container_id) -> Exploit:
        return self.running_exploits[container_id].exploit
