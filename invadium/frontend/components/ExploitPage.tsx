// Copyright 2022 Dynatrace LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Portions of this code, as identified in remarks, are provided under the
// Creative Commons BY-SA 4.0 or the MIT license, and are provided without
// any warranty. In each of the remarks, we have provided attribution to the
// original creators and other attribution parties, along with the title of
// the code (if known) a copyright notice and a link to the license, and a
// statement indicating whether or not we have modified the code.

import { Box, Container, Stack, TextField, Typography } from "@mui/material";
import React, {
  Dispatch,
  SetStateAction,
  useEffect,
  useRef,
  useState,
} from "react";
import { useRouter } from "next/router";
import ExploitStep, { Status } from "@components/ExploitStep";
import { useSnackbar } from "notistack";
import ArgsContainer from "@components/ArgsContainer";
import getConfig from "next/config";
import { canonicalizeBackendUrl, getWebsocketUrl } from "@utils/UrlUtils";
const { publicRuntimeConfig } = getConfig();

export interface EnvVar {
  name: string;
  value: string;
  desc: string;
}

export interface Step {
  id: string;
  name: string;
  desc: string;
  commands: string[];
  env: EnvVar[];
}

/*
 * The detail page for an exploit, where the indivual steps can be run.
 */
const ExploitPage = () => {
  const [steps, setSteps] = useState<Step[]>([]);
  const [containerId, setContainerId] = useState<string>("");
  const [exploitId, setExploitId] = useState<string>("");
  const [exploitName, setExploitName] = useState<string>("");
  const [currentStepIndex, setCurrentStepIndex] = useState<number>(0);
  const [exploitEnv, setExploitEnv] = useState<EnvVar[]>([]);
  const wsRef = useRef<WebSocket | null>(null);
  const stepCards: JSX.Element[] = [];
  const exploitEnvContainers: JSX.Element[] = [];
  const router = useRouter();
  const { enqueueSnackbar } = useSnackbar();

  const BACKEND_API = canonicalizeBackendUrl(publicRuntimeConfig.backendUrl);

  useEffect(() => {
    const fetchSteps = async (exploitId: string) => {
      const res = await fetch(`${BACKEND_API}/exploits/${exploitId}/steps`);
      const data: Step[] = await res.json();
      setSteps(data);
    };

    const fetchExploitEnvVars = async (containerId: string) => {
      const res = await fetch(
        `${BACKEND_API}/environment/exploit?container_id=${containerId}`
      );
      if (res.status !== 200) {
        return;
      }
      const dict = await res.json();
      const envVariables = [];
      for (const key in dict) {
        if (Object.prototype.hasOwnProperty.call(dict, key)) {
          envVariables.push(dict[key]);
        }
      }
      setExploitEnv(envVariables);
    };

    if (router.isReady) {
      const { exploitParam, containerParam, exploitName } = router.query;
      const cId = String(containerParam);
      const eId = String(exploitParam);
      const eName = String(exploitName);

      setContainerId(cId);
      setExploitId(eId);
      setExploitName(eName);
      fetchSteps(eId).catch((err) => console.log(err));
      fetchExploitEnvVars(cId).catch((err) => console.log(err));
    }
  }, [router.query, router.isReady, BACKEND_API]);

  const initWebSocket = (
    callbackFunction: Function,
    setLogs: Dispatch<SetStateAction<string[]>>,
    stepId: number
  ) => {
    if (wsRef == null) {
      return;
    }

    const wsUrl = getWebsocketUrl(BACKEND_API, window.location.origin);
    wsRef.current = new WebSocket(`${wsUrl}/exploits/ws-logs`);
    wsRef.current.onopen = () => {
      setLogs([`$ ${steps[stepId].commands.join(" && ")}`]);

      wsRef.current?.send(
        JSON.stringify({
          container_id: containerId,
          exploit_id: exploitId,
          step_id: steps[stepId].id,
        })
      );
    };
    wsRef.current.onmessage = function (event: MessageEvent) {
      event.data.split("\n").forEach((element: string) => {
        setLogs((logs) => [...logs, element]);
      });
    };
    wsRef.current.onclose = function () {
      callbackFunction(Status.DONE);
    };
  };

  const stopExploitContainer = () => {
    fetch(`${BACKEND_API}/exploits/stop?container_id=${containerId}`, {
      method: "DELETE",
    }).then(async (r) => {
      await r.json();
      router.push("/");
    });
  };

  const updateEnvVariable = async (
    containerId: string,
    envName: string,
    envValue: string,
    stepId: string
  ) => {
    await fetch(
      `${BACKEND_API}/environment/${stepId === "" ? "exploit" : "step"}?` +
        new URLSearchParams({
          container_id: containerId,
          env_name: envName,
          new_value: envValue,
          step_id: stepId,
        }),
      {
        method: "PATCH",
      }
    );
  };

  steps.forEach((step, i) =>
    stepCards.push(
      <ExploitStep
        key={i}
        initWebSocket={initWebSocket}
        step={step}
        setCurrentStepIndex={setCurrentStepIndex}
        currentStepIndex={currentStepIndex}
        isLastStep={i == steps.length - 1}
        stepNo={i}
        containerId={containerId}
        deleteExploitContainer={stopExploitContainer}
        updateEnvVariables={updateEnvVariable}
        enqueueSnackbar={enqueueSnackbar}
      ></ExploitStep>
    )
  );

  exploitEnv.forEach((step, i) =>
    exploitEnvContainers.push(
      <Box key={i}>
        <Typography>{step.name}</Typography>
        <Typography>{step.desc}</Typography>
        <TextField value={step.value}></TextField>
      </Box>
    )
  );

  return (
    <Container className="mt-6">
      <Typography variant="h3">{exploitName}</Typography>
      <ArgsContainer
        containerId={containerId}
        enqueueSnackbar={enqueueSnackbar}
        stepId=""
        updateEnvVariable={updateEnvVariable}
      ></ArgsContainer>
      <Stack>{stepCards}</Stack>
    </Container>
  );
};

export default ExploitPage;
