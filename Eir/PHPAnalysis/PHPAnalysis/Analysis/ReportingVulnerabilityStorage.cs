using System;
using System.Collections.Generic;
using System.Linq;
using PHPAnalysis.Analysis.CFG;
using PHPAnalysis.Analysis.CFG.Taint;
using PHPAnalysis.Analysis.PHPDefinitions;
using PHPAnalysis.Utils;

namespace PHPAnalysis.Analysis
{
    public sealed class ReportingVulnerabilityStorage : IVulnerabilityStorage
    {
        public readonly HashSet<string> DetectedVulns = new HashSet<string>();
        public readonly HashSet<IStoredVulnerabilityInfo> PossibleInStoredVulns = new HashSet<IStoredVulnerabilityInfo>();
        public readonly HashSet<IStoredVulnerabilityInfo> PossibleOutStoredVulns = new HashSet<IStoredVulnerabilityInfo>(); 

        private readonly IVulnerabilityReporter reporter;

        public IEnumerable<IVulnerabilityInfo> Vulnerabilities
        {
            get { return DetectedVulns.Select(m => new VulnerabilityInfo() { Message = m }); }
        }

        public ReportingVulnerabilityStorage(IVulnerabilityReporter reporter, FunctionsHandler functionsHandler)
        {
            Preconditions.NotNull(reporter, "reporter");
            Preconditions.NotNull(functionsHandler, "functionsHandler");

            this.reporter = reporter;
            this.reporter.RegisterFunctionsHandler(functionsHandler);
        }

        public void AddVulnerability(IVulnerabilityInfo vulnerabilityInfo)
        {
            if (!DetectedVulns.Contains(vulnerabilityInfo.Message))
            {
                DetectedVulns.Add(vulnerabilityInfo.Message);
                reporter.ReportVulnerability(vulnerabilityInfo);
            }
        }
        public void AddPossibleStoredVulnerability(IStoredVulnerabilityInfo vulnerabilityInfo)
        {
            if (PossibleInStoredVulns.All(x => (x.Message != vulnerabilityInfo.Message || (x.Message == vulnerabilityInfo.Message
                                                && x.PossibleStoredVuln.StorageOrigin != vulnerabilityInfo.PossibleStoredVuln.StorageOrigin))) 
                && vulnerabilityInfo.PossibleStoredVuln.ICantFeelIt == IsItInYet.YesItsGoingIn)
            {
                PossibleInStoredVulns.Add(vulnerabilityInfo);
            }
            if (PossibleOutStoredVulns.All(x => (x.Message != vulnerabilityInfo.Message || (x.Message == vulnerabilityInfo.Message
                                                 && x.PossibleStoredVuln.StorageOrigin != vulnerabilityInfo.PossibleStoredVuln.StorageOrigin)))
                && vulnerabilityInfo.PossibleStoredVuln.ICantFeelIt == IsItInYet.NoImPullingOut)
            {
                PossibleOutStoredVulns.Add(vulnerabilityInfo);
            }
        }

        public void CheckForStoredVulnerabilities()
        {
            foreach (var storedVulnOut in PossibleOutStoredVulns)
            {
                var inExpr = PossibleInStoredVulns.FirstOrDefault(x => x.PossibleStoredVuln.StorageEquals(storedVulnOut.PossibleStoredVuln)
                                                                    && x.VulnerabilityType == storedVulnOut.VulnerabilityType);
                if (inExpr == null)
                {
                    continue;
                }
                reporter.ReportStoredVulnerability(new IVulnerabilityInfo[] {
                        new VulnerabilityInfo()
                        {
                            Message = inExpr.Message,
                            IncludeStack = inExpr.IncludeStack,
                            CallStack = inExpr.CallStack,
                        },
                        new VulnerabilityInfo()
                        {
                            Message = storedVulnOut.Message,
                            IncludeStack = storedVulnOut.IncludeStack,
                            CallStack = storedVulnOut.CallStack,
                        }});
            }
        }
    }
}